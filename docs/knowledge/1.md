# 复杂度分析

众所周知，**数据结构和算法是为了让代码运行得更快，更省存储空间**。那么，怎么评估代码的速度和存储空间呢？这就是本节所讲的内容，时间、空间复杂度分析。

## 大 O 复杂度表示法

!> 该部分内容参照**[极客时间-数据结构与算法之美-王峥](https://time.geekbang.org/column/intro/126?utm_campaign=guanwang&utm_source=baidu-ad&utm_medium=ppzq-pc&utm_content=title&utm_term=baidu-ad-ppzq-title)**

算法的执行效率，粗略地讲，就是算法代码执行的时间。但是，如何在不运行代码的情况下，用“肉眼”得到一段代码的执行时间呢？

这里有段非常简单的代码，求 1,2,3…n 的累加和。现在，我就带你一块来估算一下这段代码的执行时间。

```java
int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
```

假设每行代码执行的时间都一样，为 unitTime。那么这段代码的总执行时间是多少呢？
第 2、3 行代码分别需要 1 个 unitTime 的执行时间，第 4、5 行都运行了 n 遍，所以需要$2n*unitTime$的执行时间，所以这段代码总的执行时间就是 $(2n+2)*unitTime$。

按照这个分析思路，我们再来看这段代码。
```java
 int cal(int n) {
   int sum = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1;
     for (; j <= n; ++j) {
       sum = sum +  i * j;
     }
   }
 }
```
我们依旧假设每个语句的执行时间是 unitTime。那这段代码的总执行时间 T(n) 是多少呢？

第 2、3、4 行代码，每行都需要 1 个 unitTime 的执行时间，第 5、6 行代码循环执行了 n 遍，需要 $2n * unitTime $的执行时间，第 7、8 行代码循环执行了 $n^2$遍，所以需要 $2n^2 * unitTime$ 的执行时间。所以，整段代码总的执行时间为$$T(n) = (2n^2+2n+3)*unitTime$$

通过上面的计算我们可以发现，**所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。**

我们可以把这个规律总结成一个公式。注意，大 O 就要登场了！

$$T(n) = O(f(n))$$

其中，$T(n)$ 表示代码执行的时间；n 表示数据规模的大小；$f(n)$ 表示每行代码执行的次数总和。因为这是一个公式，所以用 $f(n)$ 来表示。公式中的 O，表示代码的执行时间 $T(n)$ 与 $f(n)$ 表达式成正比。

所以，第一个例子中的 $T(n) = O(2n+2)$，第二个例子中的 $T(n) = O(2n^2+2n+3)$。这就是**大 O 时间复杂度表示法**。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示**代码执行时间随数据规模增长的变化趋势**，所以，也叫作**渐进时间复杂度（asymptotic time complexity）**，简称**时间复杂度**。

当 n 很大时，你可以把它想象成 10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了，如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：$T(n) = O(n)$； $T(n) = O(n^2)$。

## 时间复杂度分析

## 几种常见时间复杂度实例分析